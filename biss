#!/bin/bash

# An actual rewrite of kiss in pure bash
# The most parts will be reused from https://github.com/kisslinux/kiss

# -e should be avoided in bash and replaced by trap '' ERROR
# XXX: Actually we could add a errortrace for error debugging if DEBUG=1
trap 'exit' ERR


log(){
    # Print a message prettily.
    #
    # All messages are printed to stderr to allow the user to hide build
    # output which is the only thing printed to stdout.
    #
    # '\033[1;32m'        Set text to color '2' and make it bold.
    # '\033[m':           Reset text formatting.
    # '${3:-->}':         If the 3rd argument is missing, set prefix to '->'.
    # '${2:+\033[1;3Xm}': If the 2nd argument exists, set text style of '$1'.
    # '${2:+\033[m}':     If the 2nd argument exists, reset text formatting.
    printf '\033[1;33m%s \033[m%b%s\033[m %s\n' \
           "${3:-->}" "${2:+\033[1;36m}" "$1" "$2" >&2
}

die(){
    # Print a message and exit with '1' (error).
    log "$1" "$2" "!>"
    exit 1
}

contains(){
    # XXX: why do we have string list.. 
    # Check if a "string list" contains a word.
    case " $1 " in *" $2 "*) return 0; esac; return 1
}

prompt(){
    read -rp  "Continue?: Press Enter to continue or Ctrl+C to abort here"
}

dosu(){
    (( cached )) || root_cache

    # Don't need to validate if we're already root
    (( ${UID:-$(id -u)} )) || return 0

    dosudo() { su "${drop_to:-root}" -c "$* >/dev/tty" >/dev/null; }

    # We will only accept printf and not heredocs
    printf '%s' "$pass" | dosudo "$@"
}

regex_replace(){
    # Escape chars for using in sed
    printf -v sea '%q' "$1"
    printf -v rep '%q' "$2"
}

pkg_lint(){
    # Check that each mandatory file in the package entry exists.
    log "$1" "Checking repository files"

    repo_dir=$(pkg_find "$1")

    cd "$repo_dir"      || die "'$repo_dir' not accessible"
    [[ -f "sources" ]]  || die "$1" "Sources file not found"
    [[ -x "build" ]]    || die "$1" "Build file not found or not executable"
    [[ -s "version" ]]  || die "$1" "Version file not found or empty"

    read -r _ version < version
    [[ "$version" ]] || die "Release field not found in version file"
}

pkg_find(){
    # Figure out which repository a package belongs to by
    # searching for directories matching the package name
    # in $KISS_PATH/*.
    [[ "$KISS_PATH" ]] || die "\$KISS_PATH needs to be set"

    # Turn the argument list into variables as we reset 
    # the list below
    query=$1
    match=$2

    shopt -s nullglob

    IFS=: read -a kiss_path <<<"$KISS_PATH"
    
    for path in "${kiss_path[@]}" $sys_db; do
        for pkg in "${path%/}"/*; do
            [[ "${pkg##*/}" == $query ]] && matched_pkg+=("$pkg") 
        done
    done


    [[ ${matched_pkg[0]} ]] || die "Package '$query' not in any repository"

    case $match in
        all)    printf '%s\n' "${matched_pkg[@]}" ;;
        *)      printf '%s\n' "${matched_pkg[0]}" ;;
    esac
}

pkg_list(){
    # print package version
    shopt -s nullglob
    
    for pkg in "$sys_db"/*; do
        [[ -d "$pkg" ]] && {
            read -r version < "$pkg/version" || version=null
            printf '%s %s\n' "${pkg##*/}" "$version"
        }
    done
}

pkg_sources(){
    # Download any remote package sources. The existence of local
    # files is also checked.
    log "$1" "Downloading sources"

    # Store each downloaded source in a directory named after the
    # package it belongs to. This avoid conflicts between two packages
    # having a source of the same name.
    mkdir -p "$src_dir/$1" && cd "$src_dir/$1"

    repo_dir=$(pkg_find "$1")
    
    while read -r src dest || [[ $src ]]; do
        # remote src (cached)
        if [[ -f "${src##*/}" ]]; then
            log "$1" "Found cached source '${src##*/}'"

        # remite git repository
        elif [[ "$src" =~ ^git\+(.*)$ ]]; then

            [[ "$2" ]] && continue

            mkdir -p "$mak_dir/$1/$dest"

            (
                repo_src="${BASH_REMATCH[1]}"
                [[ "${src##*#*}" ]] && shallow=--depth=1

                cd "$mak_dir/$1/$dest" &&
                    git clone "${shallow:---}" "${repo_src%#*}" .

            ) || die "$1" "Failed to clone $src"

        # remote source
        elif [[ "$src" == *"://"* ]]; then
            curl "$src" -fLo "${src##*/}" || {
                rm -f "${src##*/}"
                die "$1" "Failed to download $src"
            }

        # local source
        elif [[ -f "$repo_dir/$src" ]]; then
            log "$1" "Found local file '$src'"

        else
            die "$1" "No local file '$src'"
        fi

    done < "$repo_dir/sources"
}


